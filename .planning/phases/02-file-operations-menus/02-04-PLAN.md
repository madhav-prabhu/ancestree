---
phase: 02-file-operations-menus
plan: 04
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - src/utils/gedcom.ts
  - electron/main/ipc/fileHandlers.ts
  - electron/main/index.ts
  - electron/preload/index.ts
autonomous: false

must_haves:
  truths:
    - "User can export family tree to GEDCOM format"
    - "GEDCOM file has correct header with version and encoding"
    - "Individual records (INDI) include name, birth, death dates"
    - "Family records (FAM) link spouses and children"
    - "Close with unsaved changes shows confirmation dialog"
    - "User sees dirty indicator in window title when changes exist"
  artifacts:
    - path: "src/utils/gedcom.ts"
      provides: "GEDCOM 7.0 export converter"
      exports: ["exportToGedcom"]
    - path: "electron/main/ipc/fileHandlers.ts"
      provides: "Export dialog handler"
      contains: "dialog:export"
    - path: "electron/main/index.ts"
      provides: "Dirty state tracking and close confirmation"
      contains: "setDocumentEdited"
  key_links:
    - from: "src/utils/gedcom.ts"
      to: "src/models"
      via: "imports FamilyMember, Relationship types"
      pattern: "import.*from.*models"
    - from: "electron/main/index.ts"
      to: "mainWindow.setDocumentEdited"
      via: "dirty state tracking on macOS"
      pattern: "setDocumentEdited\\("
---

<objective>
Implement GEDCOM export, dirty state tracking with close confirmation, and verify complete file operations workflow.

Purpose: Complete Phase 2 with export functionality and unsaved changes protection. Users can export to GEDCOM for compatibility with genealogy software, and won't accidentally lose unsaved work.

Output:
- `src/utils/gedcom.ts` - GEDCOM 7.0 export converter
- Export dialog handler in main process
- Dirty state indicator and close confirmation
</objective>

<execution_context>
@/home/madhav/.claude/get-shit-done/workflows/execute-plan.md
@/home/madhav/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-file-operations-menus/02-RESEARCH.md
@.planning/phases/02-file-operations-menus/02-CONTEXT.md

# Prior plan summaries
@.planning/phases/02-file-operations-menus/02-01-SUMMARY.md
@.planning/phases/02-file-operations-menus/02-02-SUMMARY.md
@.planning/phases/02-file-operations-menus/02-03-SUMMARY.md

# Data models for GEDCOM conversion
@src/models/FamilyMember.ts
@src/models/Relationship.ts

# Files to extend
@electron/main/ipc/fileHandlers.ts
@electron/main/index.ts
@electron/preload/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GEDCOM Export Converter</name>
  <files>src/utils/gedcom.ts</files>
  <action>
Create `src/utils/gedcom.ts` implementing GEDCOM 7.0 export:

```typescript
import type { FamilyMember, Relationship } from '../models'

/**
 * Convert Ancestree data to GEDCOM 7.0 format
 * https://gedcom.io/specifications/FamilySearchGEDCOMv7.pdf
 */
export function exportToGedcom(
  members: FamilyMember[],
  relationships: Relationship[]
): string {
  const lines: string[] = []

  // Header
  lines.push('0 HEAD')
  lines.push('1 SOUR ANCESTREE')
  lines.push('2 VERS 1.0')
  lines.push('2 NAME Ancestree')
  lines.push('1 GEDC')
  lines.push('2 VERS 7.0')
  lines.push('1 CHAR UTF-8')
  lines.push(`1 DATE ${formatGedcomDate(new Date())}`)

  // Map member IDs to GEDCOM IDs
  const memberIdMap = new Map<string, string>()
  members.forEach((member, index) => {
    memberIdMap.set(member.id, `@I${index + 1}@`)
  })

  // Individual records
  members.forEach((member, index) => {
    const gedcomId = `@I${index + 1}@`
    lines.push(`0 ${gedcomId} INDI`)

    // Name - split into given name and surname
    const nameParts = member.name.trim().split(' ')
    const surname = nameParts.length > 1 ? nameParts.pop()! : ''
    const givenName = nameParts.join(' ')
    lines.push(`1 NAME ${givenName} /${surname}/`)
    if (givenName) lines.push(`2 GIVN ${givenName}`)
    if (surname) lines.push(`2 SURN ${surname}`)

    // Birth
    if (member.dateOfBirth || member.placeOfBirth) {
      lines.push('1 BIRT')
      if (member.dateOfBirth) {
        lines.push(`2 DATE ${formatGedcomDateFromISO(member.dateOfBirth)}`)
      }
      if (member.placeOfBirth) {
        lines.push(`2 PLAC ${member.placeOfBirth}`)
      }
    }

    // Death
    if (member.dateOfDeath) {
      lines.push('1 DEAT')
      lines.push(`2 DATE ${formatGedcomDateFromISO(member.dateOfDeath)}`)
    }

    // Notes
    if (member.notes) {
      // Split long notes into continuation lines
      const noteLines = splitLongText(member.notes, 248)
      lines.push(`1 NOTE ${noteLines[0]}`)
      for (let i = 1; i < noteLines.length; i++) {
        lines.push(`2 CONT ${noteLines[i]}`)
      }
    }
  })

  // Family records (for spouse relationships)
  const spouseRelationships = relationships.filter(r => r.type === 'spouse')
  spouseRelationships.forEach((rel, index) => {
    const famId = `@F${index + 1}@`
    const person1Id = memberIdMap.get(rel.person1Id)
    const person2Id = memberIdMap.get(rel.person2Id)

    if (person1Id && person2Id) {
      lines.push(`0 ${famId} FAM`)
      lines.push(`1 HUSB ${person1Id}`)
      lines.push(`1 WIFE ${person2Id}`)

      // Marriage date
      if (rel.marriageDate) {
        lines.push('1 MARR')
        lines.push(`2 DATE ${formatGedcomDateFromISO(rel.marriageDate)}`)
      }

      // Find children of this couple
      const parentChildRels = relationships.filter(r =>
        r.type === 'parent-child' &&
        (r.person1Id === rel.person1Id || r.person1Id === rel.person2Id)
      )

      // Group children by checking if both parents are in this couple
      const childIds = new Set<string>()
      parentChildRels.forEach(pcr => {
        // Check if the other parent is also in this couple
        const otherParentRels = relationships.filter(r =>
          r.type === 'parent-child' &&
          r.person2Id === pcr.person2Id &&
          r.person1Id !== pcr.person1Id
        )
        const otherParentInCouple = otherParentRels.some(r =>
          r.person1Id === rel.person1Id || r.person1Id === rel.person2Id
        )

        if (otherParentInCouple || otherParentRels.length === 0) {
          childIds.add(pcr.person2Id)
        }
      })

      childIds.forEach(childId => {
        const childGedcomId = memberIdMap.get(childId)
        if (childGedcomId) {
          lines.push(`1 CHIL ${childGedcomId}`)
        }
      })
    }
  })

  // Trailer
  lines.push('0 TRLR')

  return lines.join('\n')
}

function formatGedcomDate(date: Date): string {
  const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
                  'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']
  return `${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`
}

function formatGedcomDateFromISO(isoDate: string): string {
  // Handle YYYY-MM-DD format
  const parts = isoDate.split('-')
  if (parts.length === 3) {
    const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
                    'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']
    const day = parseInt(parts[2], 10)
    const month = months[parseInt(parts[1], 10) - 1]
    const year = parts[0]
    return `${day} ${month} ${year}`
  }
  // Fallback: try to parse as Date
  const date = new Date(isoDate)
  if (!isNaN(date.getTime())) {
    return formatGedcomDate(date)
  }
  // Return as-is if can't parse
  return isoDate
}

function splitLongText(text: string, maxLength: number): string[] {
  const result: string[] = []
  let remaining = text

  while (remaining.length > maxLength) {
    // Find last space within limit
    let splitIndex = remaining.lastIndexOf(' ', maxLength)
    if (splitIndex === -1) splitIndex = maxLength

    result.push(remaining.substring(0, splitIndex))
    remaining = remaining.substring(splitIndex).trim()
  }

  if (remaining) result.push(remaining)
  return result
}
```

Key GEDCOM 7.0 requirements:
- UTF-8 encoding (default, no BOM)
- 0 HEAD at start, 0 TRLR at end
- INDI records for individuals with GEDCOM IDs (@I1@, @I2@, etc.)
- FAM records for families with HUSB, WIFE, CHIL links
- Dates in "DD MMM YYYY" format (e.g., "25 DEC 1990")
  </action>
  <verify>
`npm run build` passes.
File exports `exportToGedcom` function.
Function handles empty arrays without error.
  </verify>
  <done>
GEDCOM 7.0 export converter with proper structure.
Handles names, dates, places, notes, marriages.
Links family members through FAM records.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Export Handler and Dirty State Tracking</name>
  <files>electron/main/ipc/fileHandlers.ts, electron/main/index.ts, electron/preload/index.ts</files>
  <action>
**Update `electron/main/ipc/fileHandlers.ts`:**

Add `dialog:export` handler:
```typescript
ipcMain.handle('dialog:export', async (event, { gedcomContent, defaultName }) => {
  const window = BrowserWindow.fromWebContents(event.sender)

  const result = await dialog.showSaveDialog(window!, {
    title: 'Export Family Tree',
    defaultPath: defaultName || 'family-tree.ged',
    filters: [
      { name: 'GEDCOM Files', extensions: ['ged'] },
      { name: 'JSON Files', extensions: ['json'] }
    ]
  })

  if (result.canceled || !result.filePath) {
    return { canceled: true, filePath: null }
  }

  await fs.writeFile(result.filePath, gedcomContent, 'utf-8')
  return { canceled: false, filePath: result.filePath }
})
```

**Update `electron/preload/index.ts`:**
Add 'dialog:export' to ALLOWED_CHANNELS.

Add dirty state channels:
- 'document:setDirty'
- 'document:getDirty'

**Update `electron/main/index.ts`:**

Add dirty state tracking and close confirmation:

```typescript
let isDirty = false
let currentFilePath: string | null = null

// Add IPC handlers for dirty state
ipcMain.handle('document:setDirty', (_event, dirty: boolean, filePath: string | null) => {
  isDirty = dirty
  currentFilePath = filePath

  if (mainWindow) {
    // macOS: dot in close button
    mainWindow.setDocumentEdited(dirty)

    // Update title with dirty indicator
    const baseName = filePath
      ? path.basename(filePath)
      : 'Untitled'
    const indicator = process.platform === 'darwin' ? '' : (dirty ? ' *' : '')
    mainWindow.setTitle(`${baseName}${indicator} - Ancestree`)
  }
})

ipcMain.handle('document:getDirty', () => isDirty)

// Update window close handler with unsaved changes confirmation
mainWindow.on('close', async (event) => {
  if (isDirty) {
    event.preventDefault()

    const result = await dialog.showMessageBox(mainWindow!, {
      type: 'question',
      buttons: ['Save', "Don't Save", 'Cancel'],
      defaultId: 0,
      cancelId: 2,
      title: 'Unsaved Changes',
      message: 'Do you want to save changes?',
      detail: 'Your changes will be lost if you close without saving.'
    })

    if (result.response === 0) {
      // Save - send to renderer, renderer will save then close
      mainWindow!.webContents.send('menu:save')
      // After save completes, renderer should call window.close() again
    } else if (result.response === 1) {
      // Don't Save - force close
      isDirty = false
      mainWindow!.close()
    }
    // Cancel (response === 2): do nothing, keep window open
  }
})
```

Add 'app:closeAfterSave' channel for renderer to signal save completion.
  </action>
  <verify>
`npm run build` passes.
dialog:export in fileHandlers.ts.
Close confirmation logic in main/index.ts.
Preload allowlist includes new channels.
  </verify>
  <done>
Export dialog handler for GEDCOM files.
Dirty state tracking with platform indicators.
Close confirmation prevents data loss.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 2 file operations and menu system:
- Native file dialogs (Open, Save, Save As, Export)
- Application menu with keyboard shortcuts
- Dirty state indicator (dot on macOS, asterisk on Win/Linux)
- Close confirmation for unsaved changes
- GEDCOM export
- Auto-save crash recovery
  </what-built>
  <how-to-verify>
1. Start the app: `npm run dev`

2. **Test File Operations:**
   - Press Cmd/Ctrl+N (New) - should reset to untitled state
   - Press Cmd/Ctrl+O (Open) - native dialog should appear, can open a .json file
   - Press Cmd/Ctrl+S (Save) - on first save, prompts for location
   - Press Cmd/Ctrl+Shift+S (Save As) - always prompts for location
   - File > Export - should offer GEDCOM (.ged) format option

3. **Test Menus:**
   - macOS: "Ancestree" should appear in menu bar with About, Hide, Quit
   - File menu has: New, Open, Save, Save As, Export..., Quit
   - Edit menu has: Undo, Redo, Cut, Copy, Paste, Select All
   - View menu has: Zoom controls, Fullscreen toggle
   - Help menu has: Documentation (opens browser), Report Issue (opens browser)

4. **Test Dirty State:**
   - Open DevTools console
   - Run: `await window.electronAPI.invoke('document:setDirty', true, null)`
   - macOS: close button should show dot indicator
   - Windows/Linux: title should show asterisk (e.g., "Untitled * - Ancestree")

5. **Test Close Confirmation:**
   - With dirty state set to true, try to close window
   - Should show dialog: "Do you want to save changes?" with Save / Don't Save / Cancel
   - Click Cancel - window stays open
   - Click Don't Save - window closes
   - Click Save - save dialog appears

6. **Test Keyboard Shortcuts:**
   - Cmd/Ctrl+S, Cmd/Ctrl+O, Cmd/Ctrl+N should trigger respective actions
   - Cmd/Ctrl+Q should quit (or Cmd+W close on macOS)

7. **Verify Web Mode:**
   - Run `npm run dev` and open http://localhost:5173 in browser
   - App should load without errors (file operations gracefully disabled)
  </how-to-verify>
  <resume-signal>Type "approved" to complete Phase 2, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. GEDCOM export produces valid .ged file
3. All menu items function correctly
4. Keyboard shortcuts work (Cmd/Ctrl+S/O/N)
5. Dirty state indicator shows on all platforms
6. Close confirmation prevents accidental data loss
7. Web mode continues to work (graceful degradation)
</verification>

<success_criteria>
- User can export to GEDCOM format
- Dirty state tracked and displayed in window
- Close confirmation appears with unsaved changes
- All menu keyboard shortcuts functional
- Phase 2 success criteria from roadmap met:
  1. User can save family tree via native Save dialog
  2. User can open family tree via native Open dialog
  3. File menu has New, Open, Save, Save As, Export, Quit
  4. Cmd/Ctrl+S saves, Cmd/Ctrl+O opens, Cmd/Ctrl+Q quits
  5. macOS shows "Ancestree" in menu bar with standard items
</success_criteria>

<output>
After completion, create `.planning/phases/02-file-operations-menus/02-04-SUMMARY.md`
</output>
