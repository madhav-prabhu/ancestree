---
phase: 02-file-operations-menus
plan: 04
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - src/utils/gedcom.ts
  - electron/main/ipc/fileHandlers.ts
  - electron/preload/index.ts
autonomous: true

must_haves:
  truths:
    - "User can export family tree to GEDCOM format via File > Export"
    - "GEDCOM file has correct header with version and encoding"
    - "Individual records (INDI) include name, birth, death dates"
    - "Family records (FAM) link spouses and children"
  artifacts:
    - path: "src/utils/gedcom.ts"
      provides: "GEDCOM 7.0 export converter"
      exports: ["exportToGedcom"]
    - path: "electron/main/ipc/fileHandlers.ts"
      provides: "Export dialog handler"
      contains: "dialog:export"
  key_links:
    - from: "src/utils/gedcom.ts"
      to: "src/models"
      via: "imports FamilyMember, Relationship types"
      pattern: "import.*from.*models"
    - from: "src/App.tsx"
      to: "src/utils/gedcom.ts"
      via: "calls exportToGedcom in export menu handler"
      pattern: "exportToGedcom"
---

<objective>
Implement GEDCOM 7.0 export functionality for family tree data.

Purpose: Allow users to export their family tree in the industry-standard GEDCOM format for compatibility with other genealogy software.

Output:
- `src/utils/gedcom.ts` - GEDCOM 7.0 export converter
- Export dialog handler in main process
</objective>

<execution_context>
@/home/madhav/.claude/get-shit-done/workflows/execute-plan.md
@/home/madhav/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-file-operations-menus/02-RESEARCH.md
@.planning/phases/02-file-operations-menus/02-CONTEXT.md

# Prior plan summaries
@.planning/phases/02-file-operations-menus/02-01-SUMMARY.md
@.planning/phases/02-file-operations-menus/02-02-SUMMARY.md
@.planning/phases/02-file-operations-menus/02-03-SUMMARY.md

# Data models for GEDCOM conversion
@src/models/FamilyMember.ts
@src/models/Relationship.ts

# Files to extend
@electron/main/ipc/fileHandlers.ts
@electron/preload/index.ts
@src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GEDCOM Export Converter</name>
  <files>src/utils/gedcom.ts</files>
  <action>
Create `src/utils/gedcom.ts` implementing GEDCOM 7.0 export:

```typescript
import type { FamilyMember, Relationship } from '../models'

/**
 * Convert Ancestree data to GEDCOM 7.0 format
 * https://gedcom.io/specifications/FamilySearchGEDCOMv7.pdf
 */
export function exportToGedcom(
  members: FamilyMember[],
  relationships: Relationship[]
): string {
  const lines: string[] = []

  // Header
  lines.push('0 HEAD')
  lines.push('1 SOUR ANCESTREE')
  lines.push('2 VERS 1.0')
  lines.push('2 NAME Ancestree')
  lines.push('1 GEDC')
  lines.push('2 VERS 7.0')
  lines.push('1 CHAR UTF-8')
  lines.push(`1 DATE ${formatGedcomDate(new Date())}`)

  // Map member IDs to GEDCOM IDs
  const memberIdMap = new Map<string, string>()
  members.forEach((member, index) => {
    memberIdMap.set(member.id, `@I${index + 1}@`)
  })

  // Individual records
  members.forEach((member, index) => {
    const gedcomId = `@I${index + 1}@`
    lines.push(`0 ${gedcomId} INDI`)

    // Name - split into given name and surname
    const nameParts = member.name.trim().split(' ')
    const surname = nameParts.length > 1 ? nameParts.pop()! : ''
    const givenName = nameParts.join(' ')
    lines.push(`1 NAME ${givenName} /${surname}/`)
    if (givenName) lines.push(`2 GIVN ${givenName}`)
    if (surname) lines.push(`2 SURN ${surname}`)

    // Birth
    if (member.dateOfBirth || member.placeOfBirth) {
      lines.push('1 BIRT')
      if (member.dateOfBirth) {
        lines.push(`2 DATE ${formatGedcomDateFromISO(member.dateOfBirth)}`)
      }
      if (member.placeOfBirth) {
        lines.push(`2 PLAC ${member.placeOfBirth}`)
      }
    }

    // Death
    if (member.dateOfDeath) {
      lines.push('1 DEAT')
      lines.push(`2 DATE ${formatGedcomDateFromISO(member.dateOfDeath)}`)
    }

    // Notes
    if (member.notes) {
      // Split long notes into continuation lines
      const noteLines = splitLongText(member.notes, 248)
      lines.push(`1 NOTE ${noteLines[0]}`)
      for (let i = 1; i < noteLines.length; i++) {
        lines.push(`2 CONT ${noteLines[i]}`)
      }
    }
  })

  // Family records (for spouse relationships)
  const spouseRelationships = relationships.filter(r => r.type === 'spouse')
  spouseRelationships.forEach((rel, index) => {
    const famId = `@F${index + 1}@`
    const person1Id = memberIdMap.get(rel.person1Id)
    const person2Id = memberIdMap.get(rel.person2Id)

    if (person1Id && person2Id) {
      lines.push(`0 ${famId} FAM`)
      lines.push(`1 HUSB ${person1Id}`)
      lines.push(`1 WIFE ${person2Id}`)

      // Marriage date
      if (rel.marriageDate) {
        lines.push('1 MARR')
        lines.push(`2 DATE ${formatGedcomDateFromISO(rel.marriageDate)}`)
      }

      // Find children of this couple
      const parentChildRels = relationships.filter(r =>
        r.type === 'parent-child' &&
        (r.person1Id === rel.person1Id || r.person1Id === rel.person2Id)
      )

      // Group children by checking if both parents are in this couple
      const childIds = new Set<string>()
      parentChildRels.forEach(pcr => {
        // Check if the other parent is also in this couple
        const otherParentRels = relationships.filter(r =>
          r.type === 'parent-child' &&
          r.person2Id === pcr.person2Id &&
          r.person1Id !== pcr.person1Id
        )
        const otherParentInCouple = otherParentRels.some(r =>
          r.person1Id === rel.person1Id || r.person1Id === rel.person2Id
        )

        if (otherParentInCouple || otherParentRels.length === 0) {
          childIds.add(pcr.person2Id)
        }
      })

      childIds.forEach(childId => {
        const childGedcomId = memberIdMap.get(childId)
        if (childGedcomId) {
          lines.push(`1 CHIL ${childGedcomId}`)
        }
      })
    }
  })

  // Trailer
  lines.push('0 TRLR')

  return lines.join('\n')
}

function formatGedcomDate(date: Date): string {
  const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
                  'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']
  return `${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`
}

function formatGedcomDateFromISO(isoDate: string): string {
  // Handle YYYY-MM-DD format
  const parts = isoDate.split('-')
  if (parts.length === 3) {
    const months = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN',
                    'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC']
    const day = parseInt(parts[2], 10)
    const month = months[parseInt(parts[1], 10) - 1]
    const year = parts[0]
    return `${day} ${month} ${year}`
  }
  // Fallback: try to parse as Date
  const date = new Date(isoDate)
  if (!isNaN(date.getTime())) {
    return formatGedcomDate(date)
  }
  // Return as-is if can't parse
  return isoDate
}

function splitLongText(text: string, maxLength: number): string[] {
  const result: string[] = []
  let remaining = text

  while (remaining.length > maxLength) {
    // Find last space within limit
    let splitIndex = remaining.lastIndexOf(' ', maxLength)
    if (splitIndex === -1) splitIndex = maxLength

    result.push(remaining.substring(0, splitIndex))
    remaining = remaining.substring(splitIndex).trim()
  }

  if (remaining) result.push(remaining)
  return result
}
```

Key GEDCOM 7.0 requirements:
- UTF-8 encoding (default, no BOM)
- 0 HEAD at start, 0 TRLR at end
- INDI records for individuals with GEDCOM IDs (@I1@, @I2@, etc.)
- FAM records for families with HUSB, WIFE, CHIL links
- Dates in "DD MMM YYYY" format (e.g., "25 DEC 1990")
  </action>
  <verify>
`npm run build` passes.
File exports `exportToGedcom` function.
Function handles empty arrays without error.
  </verify>
  <done>
GEDCOM 7.0 export converter with proper structure.
Handles names, dates, places, notes, marriages.
Links family members through FAM records.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Export Dialog Handler in Main Process</name>
  <files>electron/main/ipc/fileHandlers.ts, electron/preload/index.ts</files>
  <action>
**Update `electron/main/ipc/fileHandlers.ts`:**

Add the `dialog:export` handler inside the `registerFileHandlers()` function:

```typescript
import { ipcMain, dialog, BrowserWindow, app } from 'electron'
import * as fs from 'fs/promises'

export function registerFileHandlers(): void {
  // ... existing handlers (dialog:open, dialog:save, dialog:saveAs) ...

  // Add export handler
  ipcMain.handle('dialog:export', async (event, { gedcomContent, defaultName }: { gedcomContent: string; defaultName?: string }) => {
    const window = BrowserWindow.fromWebContents(event.sender)

    const result = await dialog.showSaveDialog(window!, {
      title: 'Export Family Tree',
      defaultPath: defaultName || 'family-tree.ged',
      filters: [
        { name: 'GEDCOM Files', extensions: ['ged'] },
        { name: 'All Files', extensions: ['*'] }
      ]
    })

    if (result.canceled || !result.filePath) {
      return { canceled: true, filePath: null }
    }

    await fs.writeFile(result.filePath, gedcomContent, 'utf-8')
    return { canceled: false, filePath: result.filePath }
  })
}
```

**Update `electron/preload/index.ts`:**

Add 'dialog:export' to the `ALLOWED_CHANNELS` array:

```typescript
const ALLOWED_CHANNELS = [
  'dialog:open',
  'dialog:save',
  'dialog:saveAs',
  'dialog:export',  // Add this
  'autosave:get',
  'autosave:clear',
  'autosave:has',
  'autosave:update'
] as const
```
  </action>
  <verify>
`npm run build` passes.
`dialog:export` handler exists in fileHandlers.ts.
`dialog:export` in ALLOWED_CHANNELS array.
  </verify>
  <done>
Export dialog handler for GEDCOM files.
Preload allowlist includes dialog:export.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire Export to App.tsx Menu Handler</name>
  <files>src/App.tsx</files>
  <action>
Update the menu action handler in App.tsx to handle the 'export' action:

In the `onMenuAction` useEffect (added in Plan 02-03), update the 'export' case:

```typescript
import { exportToGedcom } from './utils/gedcom'
import { isElectron } from './utils/platform'

// Inside the onMenuAction useEffect:
case 'export': {
  if (!isElectron()) break

  // Get current tree data (members and relationships from your state)
  const members = /* your members state */
  const relationships = /* your relationships state */

  // Convert to GEDCOM format
  const gedcomContent = exportToGedcom(members, relationships)

  // Get suggested filename from current file or default
  const defaultName = fileOps.fileName
    ? fileOps.fileName.replace('.json', '.ged')
    : 'family-tree.ged'

  // Show export dialog
  await window.electronAPI!.invoke('dialog:export', {
    gedcomContent,
    defaultName
  })
  break
}
```

**NOTE:** Adapt to match your actual state variable names for members and relationships.
  </action>
  <verify>
`npm run build` passes.
App.tsx imports exportToGedcom.
Export case in menu handler calls exportToGedcom and dialog:export.
  </verify>
  <done>
Export menu action wired to GEDCOM conversion and save dialog.
Complete circuit: File > Export -> GEDCOM converter -> native save dialog.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. GEDCOM export function handles edge cases (empty arrays, missing dates)
3. Export dialog shows .ged as default format
4. File > Export triggers full export flow
5. Exported .ged file has valid GEDCOM structure
</verification>

<success_criteria>
- User can export to GEDCOM format via File > Export menu
- GEDCOM file has proper header (SOUR ANCESTREE, GEDC 7.0, CHAR UTF-8)
- Individual records include name, birth date, death date, birthplace
- Family records link spouses and children correctly
- Export dialog suggests .ged extension
</success_criteria>

<output>
After completion, create `.planning/phases/02-file-operations-menus/02-04-SUMMARY.md`
</output>
