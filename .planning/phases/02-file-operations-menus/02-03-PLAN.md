---
phase: 02-file-operations-menus
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/hooks/useFileOperations.ts
  - electron/main/services/autoSave.ts
  - electron/main/index.ts
  - electron/preload/index.ts
  - electron/preload/index.d.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "React hook provides save/open/saveAs/newFile functions"
    - "Hook tracks isDirty state when data changes"
    - "Hook tracks current filePath after save/open"
    - "Auto-save writes draft to temp location periodically"
    - "Draft can be recovered on app restart after crash"
  artifacts:
    - path: "src/hooks/useFileOperations.ts"
      provides: "React hook for file operations"
      exports: ["useFileOperations"]
    - path: "electron/main/services/autoSave.ts"
      provides: "Auto-save service using electron-store"
      exports: ["startAutoSave", "stopAutoSave", "getDraft", "clearDraft", "hasDraft"]
    - path: "electron/preload/index.ts"
      provides: "Auto-save IPC channels in allowlist"
      contains: "autosave:get"
  key_links:
    - from: "src/hooks/useFileOperations.ts"
      to: "window.electronAPI"
      via: "invoke calls for file dialogs"
      pattern: "electronAPI.*invoke.*dialog:"
    - from: "electron/main/index.ts"
      to: "electron/main/services/autoSave.ts"
      via: "IPC handlers for auto-save"
      pattern: "autosave:"
---

<objective>
Create React hook for file operations and implement auto-save crash recovery system.

Purpose: Give the renderer a clean API for file operations (save, open, saveAs, new) with automatic dirty state tracking. Auto-save provides crash recovery so users don't lose work.

Output:
- `src/hooks/useFileOperations.ts` - React hook for file operations
- `electron/main/services/autoSave.ts` - Auto-save service with electron-store
- Extended preload for auto-save IPC
</objective>

<execution_context>
@/home/madhav/.claude/get-shit-done/workflows/execute-plan.md
@/home/madhav/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-file-operations-menus/02-RESEARCH.md
@.planning/phases/02-file-operations-menus/02-CONTEXT.md

# Prior plan summaries
@.planning/phases/02-file-operations-menus/02-01-SUMMARY.md
@.planning/phases/02-file-operations-menus/02-02-SUMMARY.md

# Existing files to extend
@electron/main/index.ts
@electron/preload/index.ts
@electron/preload/index.d.ts

# Platform detection utility
@src/utils/platform.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install electron-store and Create Auto-Save Service</name>
  <files>package.json, electron/main/services/autoSave.ts, electron/main/index.ts</files>
  <action>
**Install electron-store:**
```bash
npm install electron-store
```

**Create `electron/main/services/autoSave.ts`:**

```typescript
import Store from 'electron-store'
import { ipcMain } from 'electron'

interface AutoSaveData {
  filePath: string | null
  data: unknown
  timestamp: number
}

interface StoreSchema {
  draft: AutoSaveData | null
}

const draftStore = new Store<StoreSchema>({
  name: 'ancestree-draft',
  defaults: { draft: null }
})

// Auto-save interval: 30 seconds
const AUTO_SAVE_INTERVAL = 30000
let autoSaveTimer: NodeJS.Timeout | null = null
let currentData: unknown = null
let currentFilePath: string | null = null

export function startAutoSave(): void {
  stopAutoSave()
  autoSaveTimer = setInterval(() => {
    if (currentData !== null) {
      draftStore.set('draft', {
        filePath: currentFilePath,
        data: currentData,
        timestamp: Date.now()
      })
    }
  }, AUTO_SAVE_INTERVAL)
}

export function stopAutoSave(): void {
  if (autoSaveTimer) {
    clearInterval(autoSaveTimer)
    autoSaveTimer = null
  }
}

export function updateAutoSaveData(data: unknown, filePath: string | null): void {
  currentData = data
  currentFilePath = filePath
}

export function clearDraft(): void {
  draftStore.delete('draft')
  currentData = null
  currentFilePath = null
}

export function getDraft(): AutoSaveData | null {
  return draftStore.get('draft')
}

export function hasDraft(): boolean {
  const draft = getDraft()
  return draft !== null && draft.data !== null
}

export function registerAutoSaveHandlers(): void {
  ipcMain.handle('autosave:get', () => getDraft())
  ipcMain.handle('autosave:clear', () => { clearDraft(); return true })
  ipcMain.handle('autosave:has', () => hasDraft())
  ipcMain.handle('autosave:update', (_event, data: unknown, filePath: string | null) => {
    updateAutoSaveData(data, filePath)
    return true
  })
}
```

**Update `electron/main/index.ts`:**
- Import `{ registerAutoSaveHandlers, startAutoSave, stopAutoSave }` from './services/autoSave'
- Call `registerAutoSaveHandlers()` in `app.whenReady()` before `createWindow()`
- Call `startAutoSave()` after window creation
- Call `stopAutoSave()` in `app.on('before-quit')` handler
  </action>
  <verify>
`npm run build` passes.
`electron/main/services/autoSave.ts` exists with all exports.
`electron/main/index.ts` registers auto-save handlers.
  </verify>
  <done>
electron-store installed for atomic draft storage.
Auto-save service with 30-second interval.
IPC handlers for draft read/write/clear.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend Preload with Auto-Save Channels</name>
  <files>electron/preload/index.ts, electron/preload/index.d.ts</files>
  <action>
**Update `electron/preload/index.ts`:**

Add auto-save channels to `ALLOWED_CHANNELS`:
- 'autosave:get'
- 'autosave:clear'
- 'autosave:has'
- 'autosave:update'

**Update `electron/preload/index.d.ts`:**

Add auto-save types:
```typescript
interface AutoSaveData {
  filePath: string | null
  data: unknown
  timestamp: number
}
```

Export `AutoSaveData` interface.
  </action>
  <verify>
`npm run build` passes.
ALLOWED_CHANNELS includes all 4 autosave channels.
Types exported from index.d.ts.
  </verify>
  <done>
Auto-save IPC channels in allowlist.
TypeScript types for auto-save data.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useFileOperations React Hook</name>
  <files>src/hooks/useFileOperations.ts</files>
  <action>
Create `src/hooks/useFileOperations.ts`:

```typescript
import { useState, useEffect, useCallback } from 'react'
import { isElectron } from '../utils/platform'

interface FileState {
  filePath: string | null
  isDirty: boolean
  isLoading: boolean
  error: string | null
  fileName: string
}

interface UseFileOperationsReturn extends FileState {
  save: (data: unknown) => Promise<boolean>
  saveAs: (data: unknown) => Promise<boolean>
  open: () => Promise<unknown | null>
  newFile: () => void
  markDirty: () => void
  markClean: () => void
  updateAutoSave: (data: unknown) => Promise<void>
  checkForDraft: () => Promise<{ hasDraft: boolean; draft: unknown | null }>
  clearDraft: () => Promise<void>
}

export function useFileOperations(): UseFileOperationsReturn {
  const [state, setState] = useState<FileState>({
    filePath: null,
    isDirty: false,
    isLoading: false,
    error: null,
    fileName: 'Untitled'
  })

  const getFileName = (filePath: string | null): string => {
    if (!filePath) return 'Untitled'
    const parts = filePath.split(/[/\\]/)
    return parts[parts.length - 1].replace('.json', '')
  }

  const save = useCallback(async (data: unknown): Promise<boolean> => {
    if (!isElectron()) return false

    setState(s => ({ ...s, isLoading: true, error: null }))

    try {
      const result = await window.electronAPI!.invoke('dialog:save', {
        data,
        filePath: state.filePath
      }) as { canceled: boolean; filePath: string | null }

      if (!result.canceled && result.filePath) {
        setState(s => ({
          ...s,
          filePath: result.filePath,
          fileName: getFileName(result.filePath),
          isDirty: false,
          isLoading: false
        }))
        return true
      }

      setState(s => ({ ...s, isLoading: false }))
      return false
    } catch (err) {
      setState(s => ({
        ...s,
        error: (err as Error).message,
        isLoading: false
      }))
      return false
    }
  }, [state.filePath])

  const saveAs = useCallback(async (data: unknown): Promise<boolean> => {
    if (!isElectron()) return false

    setState(s => ({ ...s, isLoading: true, error: null }))

    try {
      const result = await window.electronAPI!.invoke('dialog:saveAs', {
        data,
        defaultPath: state.filePath || 'Untitled.json'
      }) as { canceled: boolean; filePath: string | null }

      if (!result.canceled && result.filePath) {
        setState(s => ({
          ...s,
          filePath: result.filePath,
          fileName: getFileName(result.filePath),
          isDirty: false,
          isLoading: false
        }))
        return true
      }

      setState(s => ({ ...s, isLoading: false }))
      return false
    } catch (err) {
      setState(s => ({
        ...s,
        error: (err as Error).message,
        isLoading: false
      }))
      return false
    }
  }, [state.filePath])

  const open = useCallback(async (): Promise<unknown | null> => {
    if (!isElectron()) return null

    setState(s => ({ ...s, isLoading: true, error: null }))

    try {
      const result = await window.electronAPI!.invoke('dialog:open') as {
        canceled: boolean
        data: unknown | null
        filePath: string | null
        error?: string
      }

      if (result.error) {
        setState(s => ({ ...s, error: result.error!, isLoading: false }))
        return null
      }

      if (!result.canceled && result.data) {
        setState({
          filePath: result.filePath,
          fileName: getFileName(result.filePath),
          isDirty: false,
          isLoading: false,
          error: null
        })
        return result.data
      }

      setState(s => ({ ...s, isLoading: false }))
      return null
    } catch (err) {
      setState(s => ({
        ...s,
        error: (err as Error).message,
        isLoading: false
      }))
      return null
    }
  }, [])

  const newFile = useCallback(() => {
    setState({
      filePath: null,
      fileName: 'Untitled',
      isDirty: false,
      isLoading: false,
      error: null
    })
  }, [])

  const markDirty = useCallback(() => {
    setState(s => ({ ...s, isDirty: true }))
  }, [])

  const markClean = useCallback(() => {
    setState(s => ({ ...s, isDirty: false }))
  }, [])

  const updateAutoSave = useCallback(async (data: unknown): Promise<void> => {
    if (!isElectron()) return
    await window.electronAPI!.invoke('autosave:update', data, state.filePath)
  }, [state.filePath])

  const checkForDraft = useCallback(async () => {
    if (!isElectron()) return { hasDraft: false, draft: null }
    const hasDraft = await window.electronAPI!.invoke('autosave:has') as boolean
    if (!hasDraft) return { hasDraft: false, draft: null }
    const draft = await window.electronAPI!.invoke('autosave:get') as { data: unknown } | null
    return { hasDraft: true, draft: draft?.data || null }
  }, [])

  const clearDraft = useCallback(async (): Promise<void> => {
    if (!isElectron()) return
    await window.electronAPI!.invoke('autosave:clear')
  }, [])

  return {
    ...state,
    save,
    saveAs,
    open,
    newFile,
    markDirty,
    markClean,
    updateAutoSave,
    checkForDraft,
    clearDraft
  }
}
```

Key behaviors:
- On web (not Electron), methods return false/null gracefully
- save() prompts on first save, overwrites silently after
- saveAs() always prompts
- open() returns loaded data for caller to handle
- newFile() resets state to initial
- Auto-save methods for crash recovery
  </action>
  <verify>
`npm run build` passes.
Hook exports `useFileOperations` function.
All methods handle non-Electron gracefully.
  </verify>
  <done>
React hook with full file operation API.
Dirty state tracking built-in.
Auto-save integration for crash recovery.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` passes
2. electron-store in package.json dependencies
3. Auto-save service registered in main process
4. IPC channels for autosave:* in preload allowlist
5. useFileOperations hook compiles and exports
6. Hook methods work in Electron context
</verification>

<success_criteria>
- electron-store installed and configured
- Auto-save writes draft every 30 seconds
- Draft stored atomically (crash-safe)
- React hook provides save/open/saveAs/newFile
- Hook tracks isDirty and filePath state
- Works gracefully in web-only mode (no crashes)
</success_criteria>

<output>
After completion, create `.planning/phases/02-file-operations-menus/02-03-SUMMARY.md`
</output>
