---
phase: 08-fix-ui-bugs
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/models/FamilyMember.ts
  - src/scene/galaxy/PhysicsContext.tsx
  - src/scene/TreeScene.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Node positions persist after dragging and are restored on refresh"
    - "Dragged node positions are saved to storage"
    - "Custom positions are included in file exports"
    - "Imported files with positions restore node locations"
  artifacts:
    - path: "src/models/FamilyMember.ts"
      provides: "Optional position field on FamilyMember interface"
      contains: "position?: { x: number; y: number; z: number }"
    - path: "src/scene/galaxy/PhysicsContext.tsx"
      provides: "onPositionChange callback for position persistence"
      contains: "onPositionChange"
    - path: "src/scene/TreeScene.tsx"
      provides: "Position merging and callback wiring"
      contains: "member.position"
  key_links:
    - from: "src/scene/galaxy/PhysicsContext.tsx (endDrag)"
      to: "onPositionChange callback"
      via: "callback invocation"
      pattern: "onPositionChange\\?"
    - from: "src/scene/TreeScene.tsx"
      to: "updateMember"
      via: "position change handler"
      pattern: "updateMember.*position"
---

<objective>
Fix node position persistence after dragging.

Purpose: When users drag nodes to custom positions, those positions are lost on refresh because they're only stored in-memory in PhysicsContext. The fix extends the FamilyMember model with an optional position field, adds a callback to PhysicsContext for when drag ends, and wires TreeScene to persist positions via updateMember.

Output: Node positions persist across refresh, save/load, and export/import operations.
</objective>

<execution_context>
@/home/madhav/.claude/get-shit-done/workflows/execute-plan.md
@/home/madhav/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-fix-ui-bugs/08-RESEARCH.md

Key files:
@src/models/FamilyMember.ts (model to extend)
@src/scene/galaxy/PhysicsContext.tsx (endDrag callback to add)
@src/scene/TreeScene.tsx (position merging and callback wiring)
@src/hooks/useFamilyData.ts (updateMember function signature)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add position field to FamilyMember model</name>
  <files>src/models/FamilyMember.ts</files>
  <action>
  Add an optional `position` field to the FamilyMember interface.

  Add after the `photo` field:
  ```typescript
  position?: { x: number; y: number; z: number }  // Custom position from drag
  ```

  This field is optional, so:
  - Old exports without positions will import correctly (undefined = use calculated)
  - No Dexie schema migration needed (Dexie handles new optional fields automatically)
  - Export format automatically includes position when present
  </action>
  <verify>
  `npm run build` passes - TypeScript compiles without errors.
  </verify>
  <done>
  FamilyMember interface has optional position field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add onPositionChange callback to PhysicsContext</name>
  <files>src/scene/galaxy/PhysicsContext.tsx</files>
  <action>
  Extend PhysicsContext to notify parent when a node's position changes after drag.

  1. Update PhysicsProviderProps interface to add callback:
  ```typescript
  interface PhysicsProviderProps {
    positions: Map<string, { x: number; y: number; z: number }>
    relationships: Array<{ person1Id: string; person2Id: string }>
    onPositionChange?: (id: string, position: { x: number; y: number; z: number }) => void
    children: React.ReactNode
  }
  ```

  2. Update PhysicsProvider function signature to destructure the new prop:
  ```typescript
  export function PhysicsProvider({ positions, onPositionChange, children }: PhysicsProviderProps) {
  ```
  (Note: `relationships` prop is already unused in the function, can leave as-is for backward compat)

  3. Update endDrag callback to call onPositionChange:
  ```typescript
  const endDrag = useCallback((id: string) => {
    const node = nodesRef.current.get(id)
    if (node) {
      node.isDragging = false
      node.anchorPosition.copy(node.position)
      draggedIdRef.current = null
      // Persist the new position
      onPositionChange?.(id, {
        x: node.position.x,
        y: node.position.y,
        z: node.position.z
      })
    }
  }, [onPositionChange])
  ```

  The callback is optional, so existing usage without it will continue working.
  </action>
  <verify>
  `npm run build` passes - no TypeScript errors.
  </verify>
  <done>
  PhysicsContext calls onPositionChange when drag ends.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire position persistence in TreeScene and App</name>
  <files>src/scene/TreeScene.tsx, src/App.tsx</files>
  <action>
  Connect the position callback through TreeScene to App, and merge persisted positions with calculated layout.

  **In TreeScene.tsx:**

  1. Update TreeSceneProps interface to add position change handler:
  ```typescript
  interface TreeSceneProps {
    members: FamilyMember[]
    relationships: Relationship[]
    selectedMemberId?: string
    onMemberSelect: (member: FamilyMember) => void
    onCameraTargetChange?: (target: { x: number; y: number; z: number }) => void
    navigateToPosition?: { x: number; y: number; z: number } | null
    onPositionChange?: (memberId: string, position: { x: number; y: number; z: number }) => void
  }
  ```

  2. Add prop to TreeScene destructuring and pass to SceneContent:
  ```typescript
  export function TreeScene({
    members,
    relationships,
    selectedMemberId,
    onMemberSelect,
    onCameraTargetChange,
    navigateToPosition,
    onPositionChange,
  }: TreeSceneProps) {
    // ...
    return (
      <Canvas ...>
        <SceneContent
          // ... existing props
          onPositionChange={onPositionChange}
        />
      </Canvas>
    )
  }
  ```

  3. Update SceneContent props and pass to PhysicsProvider:
  ```typescript
  const SceneContent = memo(function SceneContent({
    // ... existing props
    onPositionChange,
  }: {
    // ... existing types
    onPositionChange?: (memberId: string, position: { x: number; y: number; z: number }) => void
  }) {
    // ...
    return (
      <PhysicsProvider
        positions={positions}
        relationships={relationships}
        onPositionChange={onPositionChange}
      >
        {/* ... */}
      </PhysicsProvider>
    )
  })
  ```

  4. Update positions calculation to merge persisted positions with calculated:
  ```typescript
  // Calculate positions from layout algorithm, then overlay persisted positions
  const positions = useMemo(() => {
    const calculated = calculateTreeLayout(members, relationships)
    // Overlay saved positions from members
    for (const member of members) {
      if (member.position) {
        calculated.set(member.id, member.position)
      }
    }
    return calculated
  }, [members, relationships])
  ```

  **In App.tsx:**

  5. Create a position change handler that calls updateMember:
  ```typescript
  // Handler for node position changes (drag end)
  const handlePositionChange = useCallback(async (memberId: string, position: { x: number; y: number; z: number }) => {
    await updateMember(memberId, { position })
  }, [updateMember])
  ```

  6. Pass the handler to TreeScene:
  ```typescript
  <TreeScene
    members={members}
    relationships={relationships}
    selectedMemberId={selectedMember?.id}
    onMemberSelect={handleMemberSelect}
    onCameraTargetChange={handleCameraTargetChange}
    navigateToPosition={minimapNavTarget}
    onPositionChange={handlePositionChange}
  />
  ```
  </action>
  <verify>
  1. `npm run build` passes
  2. `npm run lint` passes
  3. `npm run test` passes
  4. Confirm position field auto-serializes in JSON export/import (TypeScript types ensure FamilyMember.position is included when present since it's part of the interface - no additional serialization code needed)
  </verify>
  <done>
  Position changes are persisted via updateMember when drag ends, and restored from member.position on load. Position field is automatically included in JSON exports (TypeScript interface ensures type safety).
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. Build passes: `npm run build`
2. Tests pass: `npm run test`
3. Lint passes: `npm run lint`
4. Type check: position field flows from model through physics to storage
</verification>

<success_criteria>
- Build, test, and lint all pass
- FamilyMember model has optional position field
- PhysicsContext calls onPositionChange on drag end
- TreeScene merges persisted positions with calculated layout
- App.tsx wires position changes to updateMember
- Positions persist across page refresh
</success_criteria>

<output>
After completion, create `.planning/phases/08-fix-ui-bugs/08-02-SUMMARY.md`
</output>
